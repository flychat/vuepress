(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{194:function(t,a,e){"use strict";e.r(a);var s=e(0),r=Object(s.a)({},function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",[t._v("#php学习笔记")]),t._v(" "),e("h2",{attrs:{id:"php历史"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#php历史","aria-hidden":"true"}},[t._v("#")]),t._v(" php历史")]),t._v(" "),e("h2",{attrs:{id:"php基本语法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#php基本语法","aria-hidden":"true"}},[t._v("#")]),t._v(" php基本语法")]),t._v(" "),e("h2",{attrs:{id:"oop-面向对象编程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#oop-面向对象编程","aria-hidden":"true"}},[t._v("#")]),t._v(" OOP 面向对象编程")]),t._v(" "),e("h3",{attrs:{id:"类与对象"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#类与对象","aria-hidden":"true"}},[t._v("#")]),t._v(" 类与对象")]),t._v(" "),e("ol",[e("li",[t._v("类是抽象的、概念的，代表一类事物")]),t._v(" "),e("li",[t._v("对象是具体的，实际的，代表一个具体事物")]),t._v(" "),e("li",[t._v("类是对象的模版，对象是类的一个个实例。")])]),t._v(" "),e("h4",{attrs:{id:"如何定义一个类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何定义一个类","aria-hidden":"true"}},[t._v("#")]),t._v(" 如何定义一个类")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("class Cat{\n\t//声明成员属性 （变量）\n\tpublic $name; //属性必需要有访问控制符\n\tprotected $age;\n\tprivate $owner;\n}\n")])])]),e("h4",{attrs:{id:"类名规范"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#类名规范","aria-hidden":"true"}},[t._v("#")]),t._v(" 类名规范")]),t._v(" "),e("ol",[e("li",[t._v("首字母大写（ 但是  $cat1 = new CAT(); //类名 不区分大小写）")]),t._v(" "),e("li",[t._v("驼峰命名")]),t._v(" "),e("li",[t._v("名词在前")]),t._v(" "),e("li",[t._v("动词在后")])]),t._v(" "),e("h4",{attrs:{id:"如何创建对象"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何创建对象","aria-hidden":"true"}},[t._v("#")]),t._v(" 如何创建对象")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$cat1 = new Cat;\n\n$cat1 = new Cat();\n")])])]),e("h4",{attrs:{id:"成员属性-成员变量"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#成员属性-成员变量","aria-hidden":"true"}},[t._v("#")]),t._v(" 成员属性/成员变量")]),t._v(" "),e("p",[t._v("​\t是类的组成部分，可以是基本数据类型或符合数据类型（对象、数组）或资源或NULL")]),t._v(" "),e("h5",{attrs:{id:"访问成员属性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#访问成员属性","aria-hidden":"true"}},[t._v("#")]),t._v(" 访问成员属性")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("echo $cat1->name; //使用对象运算符  ->\n")])])]),e("p",[t._v("#####对象运算符  ->")]),t._v(" "),e("h5",{attrs:{id:"对象传递机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#对象传递机制","aria-hidden":"true"}},[t._v("#")]),t._v(" 对象传递机制")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("\t$cat1 = new Cat();\n\t$cat1->name = 'xiaohua';\n\t$cat2 = $cat1; //值传递：传递的是对象的引用reference，对象标识符\n\t$cat2 = 'abc'; //不影响$cat1\n\t\n\t$cat3 = &$cat1; //地址引用\n\t$cat3 = 'def'; //此时改变了$cat1\n\t\n")])])]),e("h4",{attrs:{id:"查看对象标识符-1"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#查看对象标识符-1","aria-hidden":"true"}},[t._v("#")]),t._v(" 查看对象标识符 #1")]),t._v(" "),e("p",[t._v("​\tvar_dump($cat1);")]),t._v(" "),e("h4",{attrs:{id:"成员函数-成员方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#成员函数-成员方法","aria-hidden":"true"}},[t._v("#")]),t._v(" 成员函数/成员方法")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("class Cat{\n\t//声明成员属性 （变量）\n\tpublic $name; //属性必需要有访问控制符\n\tprotected $age;\n\t\n\tpublic function cry(){\n\t\techo 'miao';\n\t}\n}\n")])])]),e("h5",{attrs:{id:"调用成员函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#调用成员函数","aria-hidden":"true"}},[t._v("#")]),t._v(" 调用成员函数")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$cat1 = new Cat;\n//cry();//不可以直接调用\n$cat1->cry();\n")])])]),e("h4",{attrs:{id:"构造函数-construct"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#构造函数-construct","aria-hidden":"true"}},[t._v("#")]),t._v(" 构造函数__construct")]),t._v(" "),e("ol",[e("li",[t._v("是类的一个特殊方法")]),t._v(" "),e("li",[t._v("主要作用是 创建对象时 直接"),e("strong",[t._v("初始化")]),t._v(" 赋值")]),t._v(" "),e("li",[t._v("没有返回值")]),t._v(" "),e("li",[t._v("实例化对象时 系统会自动调用")]),t._v(" "),e("li",[t._v("构造函数只能有一个")]),t._v(" "),e("li",[t._v("老版本（php4中）构造函数和类名相同 (改类名了怎么办？)，如果有2个形式的构造函数，则优先使用__construct")]),t._v(" "),e("li",[t._v("如果定义构造函数后，会覆盖系统默认的空构造函数")]),t._v(" "),e("li",[t._v("默认的构造函数方法访问修饰符是public")])]),t._v(" "),e("h5",{attrs:{id:"this-当前对象（调用者）"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#this-当前对象（调用者）","aria-hidden":"true"}},[t._v("#")]),t._v(" this 当前对象（调用者）")]),t._v(" "),e("ol",[e("li",[t._v("系统会给每个对象分配this，代表当前对象（自己的，我的）")]),t._v(" "),e("li",[t._v("this时当前的"),e("strong",[t._v("执行环境")])]),t._v(" "),e("li",[t._v("this不能在类外部使用")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("class Cat{\n\tpublic $name;\n\tpublic $age;\n\t\n\tpublic function __contruct($iname,$iage){\n\t\t//$name = $iname;\n\t\tvar_dump($this);\n\t\t$this->name = $iname;\n\t\t$this->age = $iage;\n\t}\n\n}\n\n$cat1 = new Cat('xiaohua',3);\necho $cat1->name . $cat1->age;\n")])])]),e("h4",{attrs:{id:"析构函数-destruct"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#析构函数-destruct","aria-hidden":"true"}},[t._v("#")]),t._v(" 析构函数__destruct")]),t._v(" "),e("p",[t._v("作用：释放相关资源")]),t._v(" "),e("p",[t._v("code："),e("code",[t._v("function __destruct() { }")])]),t._v(" "),e("p",[t._v("先创建的对象后销毁 栈")]),t._v(" "),e("h6",{attrs:{id:"说明"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#说明","aria-hidden":"true"}},[t._v("#")]),t._v(" 说明")]),t._v(" "),e("ol",[e("li",[t._v("当没有变量指向某个对象时（所有引用都被删除），这个对象就会被销毁")]),t._v(" "),e("li",[t._v("在对象销毁之前，会调用析构函数")]),t._v(" "),e("li",[t._v("析构函数不是销毁对象本身，而是销毁对象创建的相关资源，如数据库连接等")])]),t._v(" "),e("h6",{attrs:{id:"使用场合-最佳事件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用场合-最佳事件","aria-hidden":"true"}},[t._v("#")]),t._v(" 使用场合/最佳事件")]),t._v(" "),e("ol",[e("li",[t._v("希望在程序还没结束前，就销毁某些实例（显性删除 $cat1 = null;或指向其他）")]),t._v(" "),e("li",[t._v("及时销毁对象创建的资源，如数据库连接等")])]),t._v(" "),e("h4",{attrs:{id:"垃圾回收♻️机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收♻️机制","aria-hidden":"true"}},[t._v("#")]),t._v(" 垃圾回收♻️机制")]),t._v(" "),e("pre",[e("code",[t._v("1. 当一个对象没有任何引用（变量）指向它的时候，就会成为一个垃圾对象，php就会启动垃圾回收器将其销毁\n2. 当程序退出前，php也将启用垃圾回收器，销毁对象\n3. php5.3自后对垃圾回收算法优化，解决了**引用环**问题\n4. 对象标识符合的引用次数, 每个对象都会分配一个计数器\n")])]),t._v(" "),e("h3",{attrs:{id:"类的魔术方法-magic-methods"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#类的魔术方法-magic-methods","aria-hidden":"true"}},[t._v("#")]),t._v(" 类的魔术方法 Magic methods")]),t._v(" "),e("ol",[e("li",[t._v("在满足某种条件下会被系统自动调用（不可手动调用）")]),t._v(" "),e("li",[t._v("都是以——开头的函数")])]),t._v(" "),e("p",[t._v("####一览表")]),t._v(" "),e("ol",[e("li",[t._v("__construct")]),t._v(" "),e("li",[t._v("__destruct")]),t._v(" "),e("li",[t._v("__call  当对象调用一个不可访问或不存在的方法时，__call会被调用。")]),t._v(" "),e("li",[t._v("__callStatic")]),t._v(" "),e("li",[t._v("__set")]),t._v(" "),e("li",[t._v("__get")]),t._v(" "),e("li",[t._v("__isset")]),t._v(" "),e("li",[t._v("__unset")]),t._v(" "),e("li",[t._v("__sleep")]),t._v(" "),e("li",[t._v("__wakeup")]),t._v(" "),e("li",[t._v("__toString")]),t._v(" "),e("li",[t._v("__set_state")]),t._v(" "),e("li",[t._v("__clone")])]),t._v(" "),e("h4",{attrs:{id:"访问修饰符"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#访问修饰符","aria-hidden":"true"}},[t._v("#")]),t._v(" 访问修饰符")]),t._v(" "),e("p",[t._v("对属性或方法的访问控制 Access Control 通过在前面添加关键字 public protected private")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th"),t._v(" "),e("th",[t._v("public")]),t._v(" "),e("th",[t._v("protected")]),t._v(" "),e("th",[t._v("private")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("类内")]),t._v(" "),e("td",[t._v("√")]),t._v(" "),e("td",[t._v("√")]),t._v(" "),e("td",[t._v("√")])]),t._v(" "),e("tr",[e("td",[t._v("类外")]),t._v(" "),e("td",[t._v("√")]),t._v(" "),e("td",[t._v("X")]),t._v(" "),e("td",[t._v("X")])]),t._v(" "),e("tr",[e("td",[t._v("子类")]),t._v(" "),e("td",[t._v("√")]),t._v(" "),e("td",[t._v("√")]),t._v(" "),e("td",[t._v("X")])])])]),t._v(" "),e("p",[t._v("在类外访问private和protected属性，需要定一个public getAtt() 绕行")]),t._v(" "),e("h4",{attrs:{id:"get-set"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#get-set","aria-hidden":"true"}},[t._v("#")]),t._v(" __get __set")]),t._v(" "),e("p",[t._v("对类中不可访问/不存在的属性 访问/读取时 __get 会被自动调用")]),t._v(" "),e("p",[t._v("对类中不可访问/不存在的属性 设置/赋值时 __set 会被自动调用")]),t._v(" "),e("p",[t._v("应用： 松散型的php：给不存在的属性赋值时，会设置成功 ！使用--set可以友好提示！")]),t._v(" "),e("h4",{attrs:{id:"isset-unset"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#isset-unset","aria-hidden":"true"}},[t._v("#")]),t._v(" __isset __unset")]),t._v(" "),e("p",[t._v("对类中不可访问/不存在的属性 进行 isset() / empty()时 __isset 会被自动调用")]),t._v(" "),e("p",[t._v("对类中不可访问/不存在的属性 进行 unset()时 __unset 会被自动调用")]),t._v(" "),e("h4",{attrs:{id:"call"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#call","aria-hidden":"true"}},[t._v("#")]),t._v(" __call")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("class Cat{\n\tpublic function __call($method, $agrs){\n\t\treturn $this->$agrs[0]($agrs[1],$agrs[2]);\n\t}\n\tpublic function getSum($n1,$n2){\n\t\treturn $n1+$n2;\n\t}\n}\n\n$cat = new Cat;\n$cat->play('getSum',1,2); //3\n")])])]),e("h3",{attrs:{id:"autoload-类的自动-动态加载"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#autoload-类的自动-动态加载","aria-hidden":"true"}},[t._v("#")]),t._v(" __autoload 类的自动/动态加载")]),t._v(" "),e("p",[t._v("当使用一个没有定义过的类时，就会/才会自动触发__autoload函数")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("<?php\n//init.php\n\nfunction myAutoload($className){\n\trequire \"./Models/$className.php\";\n}\n\n/* \n\n$classMap =['Cat'=>'../Models/Cat.class.php'];\n\nfunction __autoload($className){\n  global $classMap;\n\trequire \"./Class/$className.php\";\n}\n\n*/\n$cat = new Cat();\n\nspl_autoload_register('myAutoload');\n\n")])])]),e("h3",{attrs:{id:"类的静态属性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#类的静态属性","aria-hidden":"true"}},[t._v("#")]),t._v(" 类的静态属性")]),t._v(" "),e("p",[t._v("####静态变量")]),t._v(" "),e("p",[t._v("所有对象共享公共的数据 ，可以在定义的时候初始化。")]),t._v(" "),e("p",[t._v("初始化在类加载时")]),t._v(" "),e("p",[t._v("####静态变量定义")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("public static $counts =0;\n")])])]),e("p",[t._v("####静态变量定义访问")]),t._v(" "),e("p",[t._v("​\t类内访问 ：范围解析符 self:😗*$**counts++;")]),t._v(" "),e("p",[t._v("​\t类外+类内 Cat:😗*$**counts; (需要时public)")]),t._v(" "),e("p",[t._v("任何一个对象访问时，获取的时相同的值")]),t._v(" "),e("h4",{attrs:{id:"范围解析符"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#范围解析符","aria-hidden":"true"}},[t._v("#")]),t._v(" 范围解析符 ::")]),t._v(" "),e("p",[t._v("self::")]),t._v(" "),e("p",[t._v("####对象运算符  ->")]),t._v(" "),e("h4",{attrs:{id:"this与self-区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#this与self-区别","aria-hidden":"true"}},[t._v("#")]),t._v(" $this与self::区别")]),t._v(" "),e("h3",{attrs:{id:"类的静态方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#类的静态方法","aria-hidden":"true"}},[t._v("#")]),t._v(" 类的静态方法")]),t._v(" "),e("p",[t._v("静态方法也叫类方法")]),t._v(" "),e("h4",{attrs:{id:"定义"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#定义","aria-hidden":"true"}},[t._v("#")]),t._v(" 定义")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("public static function cry(){\n\n}\n")])])]),e("h4",{attrs:{id:"使用场景-（单例模式）"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用场景-（单例模式）","aria-hidden":"true"}},[t._v("#")]),t._v(" 使用场景 （单例模式）")]),t._v(" "),e("ul",[e("li",[t._v("操作静态变量\n"),e("ul",[e("li",[t._v("静态方法中不可以访问/操作 非静态 属性/变量")])])]),t._v(" "),e("li",[t._v("没有对象实例的话，也可以调用方法")])]),t._v(" "),e("p",[t._v("####调用")]),t._v(" "),e("ul",[e("li",[t._v("在类的外部调用静态方法, 则必需为public\n"),e("ul",[e("li",[t._v("Cat::cry();")]),t._v(" "),e("li",[t._v("$cat1->cry();//不推荐")]),t._v(" "),e("li",[e("s",[t._v("$cat1::cry(); //极不推荐")])])])]),t._v(" "),e("li",[t._v("在类的内部调用静态方法，\n"),e("ul",[e("li",[t._v("self::cry(); //推荐")]),t._v(" "),e("li",[t._v("Cat::cry(); //不推荐")]),t._v(" "),e("li",[e("s",[t._v("$this->cry(); //极不推荐")])])])])]),t._v(" "),e("h4",{attrs:{id:"细节"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#细节","aria-hidden":"true"}},[t._v("#")]),t._v(" 细节")]),t._v(" "),e("h3",{attrs:{id:"封装"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#封装","aria-hidden":"true"}},[t._v("#")]),t._v(" 封装")]),t._v(" "),e("ul",[e("li",[t._v("把同一类食物的属性和行为 包装起来")])]),t._v(" "),e("h3",{attrs:{id:"继承"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#继承","aria-hidden":"true"}},[t._v("#")]),t._v(" 继承")]),t._v(" "),e("p",[t._v("是单继承的，一个类最多有一个父类\n简洁，纯洁性\n接口可以补充无法多继承的缺陷！")]),t._v(" "),e("h3",{attrs:{id:"重载overloading"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#重载overloading","aria-hidden":"true"}},[t._v("#")]),t._v(" 重载overloading")]),t._v(" "),e("h4",{attrs:{id:"call-实现同名函数但不同参数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#call-实现同名函数但不同参数","aria-hidden":"true"}},[t._v("#")]),t._v(" __call 实现同名函数但不同参数")]),t._v(" "),e("p",[t._v("####属性的重载(动态添加属性) __get() __set()")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("class Cat{\n\tprotected $pro_array = [];\n\tpublic function __set($pro_name,$val){\n\t\t$this->pro_array[$pro_name] = $val;\n\t}\n\tpublic function __get($pro_name){\n\t return $this->pro_array[$pro_name];//if isset\n\t}\n}\n$cat = new Cat();\n$cat->name = 'xiaohua';\n\n")])])]),e("h3",{attrs:{id:"重写-override"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#重写-override","aria-hidden":"true"}},[t._v("#")]),t._v(" 重写 override")]),t._v(" "),e("p",[t._v("子类重写父类public/protected方法或属性")]),t._v(" "),e("p",[t._v("重写要求 函数名和参数个数 完全一致")]),t._v(" "),e("p",[t._v("重写方法内 访问父类的的静态属性 parents::$total，但这个静态属性必需可以被子类访问（即public或protected）")]),t._v(" "),e("p",[t._v("子类可以调用父类的构造方法 parents::__construct();")]),t._v(" "),e("p",[t._v("子类必需要和父类的 类型约束 保持一致")]),t._v(" "),e("p",[t._v("子类方法不能缩小父类访问权限 Access Level")]),t._v(" "),e("h3",{attrs:{id:"类型约束"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#类型约束","aria-hidden":"true"}},[t._v("#")]),t._v(" 类型约束")]),t._v(" "),e("ul",[e("li",[t._v("对象")]),t._v(" "),e("li",[t._v("数组 array")]),t._v(" "),e("li",[t._v("callable 毁掉函数")]),t._v(" "),e("li",[t._v("如果默认值null，调用时可以为NULL")]),t._v(" "),e("li",[t._v("不能是int string traits")])]),t._v(" "),e("h3",{attrs:{id:"属性重写"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#属性重写","aria-hidden":"true"}},[t._v("#")]),t._v(" 属性重写")]),t._v(" "),e("h3",{attrs:{id:"抽象类（abstract）"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#抽象类（abstract）","aria-hidden":"true"}},[t._v("#")]),t._v(" 抽象类（abstract）")]),t._v(" "),e("h4",{attrs:{id:"为什么要使用抽象类技术"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为什么要使用抽象类技术","aria-hidden":"true"}},[t._v("#")]),t._v(" 为什么要使用抽象类技术")]),t._v(" "),e("ul",[e("li",[t._v("规范类的设计（模糊设计一个类拥有的行为）")]),t._v(" "),e("li",[t._v("关键词： abstract")]),t._v(" "),e("li",[t._v("抽象类abstract不可以实例化")]),t._v(" "),e("li",[t._v("抽象类可以没有抽象方法，但包含抽象方法的类一定是抽象类")])]),t._v(" "),e("h4",{attrs:{id:"抽象方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#抽象方法","aria-hidden":"true"}},[t._v("#")]),t._v(" 抽象方法")]),t._v(" "),e("ul",[e("li",[t._v("抽象方法不能有函数体： abstract public function say();")]),t._v(" "),e("li",[t._v("继承子类必需实现抽象类的所有abstract方法，除非它也是abstract类")]),t._v(" "),e("li",[t._v("重写overwrite子类实现的方法的访问修饰符 >= 父类")])]),t._v(" "),e("h4",{attrs:{id:"抽象类与抽象方法的关系"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#抽象类与抽象方法的关系","aria-hidden":"true"}},[t._v("#")]),t._v(" 抽象类与抽象方法的关系")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("如果一个类包含抽象方法，那么这个类一定是抽象类")])]),t._v(" "),e("li",[e("p",[t._v("抽象类中可以包含非抽象方法")])])]),t._v(" "),e("h3",{attrs:{id:"接口-interface"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#接口-interface","aria-hidden":"true"}},[t._v("#")]),t._v(" 接口 interface")]),t._v(" "),e("ul",[e("li",[t._v("接口就是生命一个方法，供其他类来实现")]),t._v(" "),e("li",[t._v("设计思想： 高内聚低耦合")]),t._v(" "),e("li",[t._v("接口就是规范，是更加抽象的抽象类，解决多层继承耦合问题")])]),t._v(" "),e("div",{staticClass:"language-interface iName{ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("interface iName{\n  //属性 iName::A\n  const A=90 \n  //方法\n}\n\nclass iPhone extents Phone implements 接口1，接口2{\n    //必需实现接口1和2的所有方法\n} ```\n\n//接口之间可以多继承 \ninterfact iUsb extents iUsb1 iUsb2{\n}\n\n")])])]),e("p",[t._v("####使用场合")]),t._v(" "),e("ul",[e("li",[t._v("定规范")]),t._v(" "),e("li",[t._v("多个同级类，同样方法wrtie()又有不同的行为。比如，有的写数据库，有的写文件")])]),t._v(" "),e("h4",{attrs:{id:"细节-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#细节-2","aria-hidden":"true"}},[t._v("#")]),t._v(" 细节")]),t._v(" "),e("ol",[e("li",[t._v("不能实例")]),t._v(" "),e("li",[t._v("接口的所有方法都不能有方法体")]),t._v(" "),e("li",[t._v("可以实现多个接口")]),t._v(" "),e("li",[t._v("接口中的属性必需是 public常量")]),t._v(" "),e("li",[t._v("接口的方法都必需是public")]),t._v(" "),e("li",[t._v("接口之间可以多继承")])]),t._v(" "),e("p",[t._v("在不打破继承关系的前提下扩充类功能，非常灵活")]),t._v(" "),e("h3",{attrs:{id:"final类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#final类","aria-hidden":"true"}},[t._v("#")]),t._v(" final类")]),t._v(" "),e("p",[t._v("不希望任何类继承的类\n不可以覆盖重写的方法也可以使用final修饰\nFinal 方法可以被继承，但不可以重写\nfinal类是可以被实例化的\nfinal public say（）｛｝\n不能修饰属性")]),t._v(" "),e("h3",{attrs:{id:"类常量-const"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#类常量-const","aria-hidden":"true"}},[t._v("#")]),t._v(" 类常量 const")]),t._v(" "),e("p",[t._v("不允许改动的 比如圆周率 不用$符号，大写，必须赋值，都必须是public")]),t._v(" "),e("h3",{attrs:{id:"多态"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#多态","aria-hidden":"true"}},[t._v("#")]),t._v(" 多态")]),t._v(" "),e("p",[t._v("php天生就是多态语言，可以通过继承父类或实现接口来体现多态。")]),t._v(" "),e("p",[t._v("好处：代码维护或扩展")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("class Animal{\n\tpublic $name;\n\tfunction __construct($name){\n\t\t$this->name = $name;\n\t}\n}\n\nclass Dog extends Animal{\n\tpublic function showInfo(){\n\t\treturn $this->name;\n\t}\n}\n\nclass Cat extends Animal{\n\tpublic function showInfo(){\n\t\treturn $this->name;\n\t}\n}\n\nclass Food{\n\tpublic $name;\n\tfunction __construct($name){\n\t\t$this->name = $name;\n\t}\n}\n\nclass Fish extends Food{\n\tpublic function showInfo(){\n\t\treturn $this->name;\n\t}\n}\n\nclass Bone extends Food{\n\tpublic function showInfo(){\n\t\treturn $this->name;\n\t}\n}\n\nclass Master {\n\tpublic\t$name;\n\t\n\t// 这里实现了多态！！！使用类型约束 限定 一下更好！\n\tpublic function feed(Animal $animal, Food $food){\n\t\techo PHP_EOL. $animal->showInfo();\n\t\techo '喜欢吃';\n\t\techo PHP_EOL. $food->showInfo();\n\t}\n}\n\n$master = new Master('xiaohong');\n$cat = new Cat('小花猫');\n$fish = new Fish('小鱼鱼');\n$master->feed($cat, $fish);\n\n$dog = new Dog('大黄');\n$bone = new Fish('大棒骨🦴');\n$master->feed($dog, $bone);\n\n")])])]),e("h3",{attrs:{id:"对象的遍历"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#对象的遍历","aria-hidden":"true"}},[t._v("#")]),t._v(" 对象的遍历")]),t._v(" "),e("ul",[e("li",[t._v("对象遍历只能遍历对象的属性值")]),t._v(" "),e("li",[t._v("在类外遍历时，只能遍历到public属性")]),t._v(" "),e("li",[t._v("如果要遍历所有属性，需要成员方法在 实例里/类里 遍历")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('public class Dog{\n\tpublic $name=\'xiaomao\';\n\tprivate $age=1;\n\tprotected $color;\n\t//内部可以访问到所有属性\n\tfunction getVars(){\n\t\tforeach($this as $key=>$val){\n\t\t\techo PHP_EOL."$key=>$val";\n\t\t}\n\t}\n}\n\n$dog1 = new Dog();\n//外部遍历到public属性\nforeach($dog as $key=>$val){\n\techo PHP_EOL."$key=>$val";\n}\n\n')])])]),e("h4",{attrs:{id:"内置标准类-stdclass"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#内置标准类-stdclass","aria-hidden":"true"}},[t._v("#")]),t._v(" 内置标准类 stdClass")]),t._v(" "),e("ul",[e("li",[t._v("php中有一个类 stdClass，不需要创建就可以使用")]),t._v(" "),e("li",[t._v("通常以对象的方式管理数据")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$person = new stdClass();\nvar_dump($person);\n$person->name = '猪八戒';\nvar_dump($persion);\n")])])]),e("h4",{attrs:{id:"其他数据类型-转换成对象"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#其他数据类型-转换成对象","aria-hidden":"true"}},[t._v("#")]),t._v(" 其他数据类型 转换成对象")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$heros = ['no1'=>'宋江'，'no2'=>'小吴'];\n//当我们把一个数组转换成一个对象后，\n//它成为一个stdClass对象实例\n//如果是一个关联数组，数组的key编程属性名\n//如果是一个索引数组？？？\n$heros = (object) $heros;\n\n\n$age=90;\n$age = (object) $age;\n")])])]),e("h3",{attrs:{id:"serialize-un-serialize"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#serialize-un-serialize","aria-hidden":"true"}},[t._v("#")]),t._v(" serialize un-serialize")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("对象的序列化和反序列化")])]),t._v(" "),e("li",[e("p",[t._v("序列化 保存为字符串 $str = serialize($obj1);")])]),t._v(" "),e("li",[e("p",[t._v("反序列化 把字符串还原为原来的对象，需要引入类的定义")]),t._v(" "),e("ul",[e("li",[t._v("$obj1 = unserialize($str);")])])])]),t._v(" "),e("h3",{attrs:{id:"trait"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#trait","aria-hidden":"true"}},[t._v("#")]),t._v(" trait")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("trait Abc{\n\tfunction sum($n1,$n2){\n\t\treturn $n1+$n2;\n\t}\n\tfunction getMax($arr){\n\t\treturn max($arr);\n\t}\n}\n\nclass Cde{\n\tuse Abc;\n}\n")])])]),e("ul",[e("li",[t._v("代码函数级别复用")]),t._v(" "),e("li",[t._v("trait不可以实例化")]),t._v(" "),e("li",[t._v("优先级为最低，可以覆盖")])]),t._v(" "),e("h3",{attrs:{id:"反射-reflectionclass"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#反射-reflectionclass","aria-hidden":"true"}},[t._v("#")]),t._v(" 反射 ReflectionClass")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("class IndexAction{\n\tpublic function index(){\n\t\techo 'Index';\n\t}\n\tpublic function test(){\n\t\techo PHP_EOL.__CLASS__.__FUNCTION__.__LINE__;\n\t}\n\t\n\tpublic function _before_index(){\n\t\techo PHP_EOL.__CLASS__.__FUNCTION__.__LINE__;\n\t}\n\t\n\tpublic function _after_index(){\n\t\techo PHP_EOL.__CLASS__.__FUNCTION__.__LINE__;\n\t}\n}\n//\nvar_dump(Reflection::export('IndexAction'));\n\n//需求是 IndexAction中的方法和访问控制符是不确定的。如果是public，可以执行\n//如果存在before/after方法，并且是public，则执行\n\n$reflector = new ReflectionClass('IndexAction');\nif($reflector->hasMethod('index')){\n\techo 'has-index';\n\t$reflectorIndex = $reflector->getMethod('index');\n\tif($reflectorIndex->isPublic()){\n\t\techo 'index is public';\n\t\t//before\n\t\tif($reflector->hasMethod('_before_index')){\n\t\t\t$reflectorBefore = $reflector->getMethod('_before_index');\n\t\t\tif($reflectorBefore->isPublic()){\n\t\t\t\t$reflectorBefore->invoke(new $reflector->newInstance());\n\t\t\t}\n\t\t}\n\t\t//index\n\t\t\n\t\t//after\n\t}\n}else{\n\techo 'no-index';\n}\n")])])])])},[],!1,null,null,null);a.default=r.exports}}]);