<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>FlyChat</title>
    <meta name="description" content="又是一片云">
    
    
    <link rel="preload" href="/assets/css/0.styles.d7d6c04a.css" as="style"><link rel="preload" href="/assets/js/app.35fdc654.js" as="script"><link rel="preload" href="/assets/js/2.8f7dda8c.js" as="script"><link rel="preload" href="/assets/js/12.8b453b2c.js" as="script"><link rel="prefetch" href="/assets/js/10.e648c570.js"><link rel="prefetch" href="/assets/js/11.8e234465.js"><link rel="prefetch" href="/assets/js/13.20cc4b20.js"><link rel="prefetch" href="/assets/js/14.d88763f5.js"><link rel="prefetch" href="/assets/js/15.c53314b5.js"><link rel="prefetch" href="/assets/js/16.41b21f98.js"><link rel="prefetch" href="/assets/js/17.faa0279f.js"><link rel="prefetch" href="/assets/js/18.1ca4c276.js"><link rel="prefetch" href="/assets/js/19.7e551fbe.js"><link rel="prefetch" href="/assets/js/20.05fbe4ec.js"><link rel="prefetch" href="/assets/js/21.245ed8d5.js"><link rel="prefetch" href="/assets/js/22.c50433bc.js"><link rel="prefetch" href="/assets/js/23.a2346185.js"><link rel="prefetch" href="/assets/js/24.26f2fd95.js"><link rel="prefetch" href="/assets/js/25.3db353f9.js"><link rel="prefetch" href="/assets/js/26.303348b3.js"><link rel="prefetch" href="/assets/js/27.5b9597f0.js"><link rel="prefetch" href="/assets/js/28.d8a1bab3.js"><link rel="prefetch" href="/assets/js/29.ed0a4ceb.js"><link rel="prefetch" href="/assets/js/3.d31ff04e.js"><link rel="prefetch" href="/assets/js/30.da9a6799.js"><link rel="prefetch" href="/assets/js/31.6052fb74.js"><link rel="prefetch" href="/assets/js/32.36d6cdbf.js"><link rel="prefetch" href="/assets/js/33.468ad020.js"><link rel="prefetch" href="/assets/js/34.cdc39912.js"><link rel="prefetch" href="/assets/js/35.a3ef273c.js"><link rel="prefetch" href="/assets/js/36.82fa38f1.js"><link rel="prefetch" href="/assets/js/37.0b740524.js"><link rel="prefetch" href="/assets/js/38.d9bde22d.js"><link rel="prefetch" href="/assets/js/39.516cf0fa.js"><link rel="prefetch" href="/assets/js/4.7bf71852.js"><link rel="prefetch" href="/assets/js/40.be53ceb2.js"><link rel="prefetch" href="/assets/js/41.6ae6d825.js"><link rel="prefetch" href="/assets/js/42.63c5f991.js"><link rel="prefetch" href="/assets/js/43.40aabd92.js"><link rel="prefetch" href="/assets/js/44.b8f54a53.js"><link rel="prefetch" href="/assets/js/45.fead0cc1.js"><link rel="prefetch" href="/assets/js/46.7cf6c3cf.js"><link rel="prefetch" href="/assets/js/47.a925b5e0.js"><link rel="prefetch" href="/assets/js/48.65342035.js"><link rel="prefetch" href="/assets/js/49.8ce64d6d.js"><link rel="prefetch" href="/assets/js/5.5f37c3fd.js"><link rel="prefetch" href="/assets/js/50.137b5aa3.js"><link rel="prefetch" href="/assets/js/51.1855968c.js"><link rel="prefetch" href="/assets/js/52.fbddb3b5.js"><link rel="prefetch" href="/assets/js/53.70b58b9c.js"><link rel="prefetch" href="/assets/js/54.751bae67.js"><link rel="prefetch" href="/assets/js/55.b9a58ec1.js"><link rel="prefetch" href="/assets/js/56.de43cea6.js"><link rel="prefetch" href="/assets/js/57.7bd6749e.js"><link rel="prefetch" href="/assets/js/58.fee497e7.js"><link rel="prefetch" href="/assets/js/59.6ed53755.js"><link rel="prefetch" href="/assets/js/6.ef997e1e.js"><link rel="prefetch" href="/assets/js/60.c93f633d.js"><link rel="prefetch" href="/assets/js/61.18fe319b.js"><link rel="prefetch" href="/assets/js/7.7d5dd07b.js"><link rel="prefetch" href="/assets/js/8.a6dc83f6.js"><link rel="prefetch" href="/assets/js/9.eded9718.js">
    <link rel="stylesheet" href="/assets/css/0.styles.d7d6c04a.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">FlyChat</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/Life/" class="nav-link">生活</a></div><div class="nav-item"><a href="/IT/" class="nav-link router-link-active">技术</a></div><div class="nav-item"><a href="https://sm.ms" target="_blank" rel="noopener noreferrer" class="nav-link external">
  图床
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/Life/" class="nav-link">生活</a></div><div class="nav-item"><a href="/IT/" class="nav-link router-link-active">技术</a></div><div class="nav-item"><a href="https://sm.ms" target="_blank" rel="noopener noreferrer" class="nav-link external">
  图床
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span></span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/IT/PHP/PHP%E5%B7%A9%E5%9B%BA%E7%AC%94%E8%AE%B0.html#php历史" class="sidebar-link">php历史</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/IT/PHP/PHP%E5%B7%A9%E5%9B%BA%E7%AC%94%E8%AE%B0.html#php基本语法" class="sidebar-link">php基本语法</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/IT/PHP/PHP%E5%B7%A9%E5%9B%BA%E7%AC%94%E8%AE%B0.html#oop-面向对象编程" class="sidebar-link">OOP 面向对象编程</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/IT/PHP/PHP%E5%B7%A9%E5%9B%BA%E7%AC%94%E8%AE%B0.html#类与对象" class="sidebar-link">类与对象</a></li><li class="sidebar-sub-header"><a href="/IT/PHP/PHP%E5%B7%A9%E5%9B%BA%E7%AC%94%E8%AE%B0.html#类的魔术方法-magic-methods" class="sidebar-link">类的魔术方法 Magic methods</a></li><li class="sidebar-sub-header"><a href="/IT/PHP/PHP%E5%B7%A9%E5%9B%BA%E7%AC%94%E8%AE%B0.html#autoload-类的自动-动态加载" class="sidebar-link">__autoload 类的自动/动态加载</a></li><li class="sidebar-sub-header"><a href="/IT/PHP/PHP%E5%B7%A9%E5%9B%BA%E7%AC%94%E8%AE%B0.html#类的静态属性" class="sidebar-link">类的静态属性</a></li><li class="sidebar-sub-header"><a href="/IT/PHP/PHP%E5%B7%A9%E5%9B%BA%E7%AC%94%E8%AE%B0.html#类的静态方法" class="sidebar-link">类的静态方法</a></li><li class="sidebar-sub-header"><a href="/IT/PHP/PHP%E5%B7%A9%E5%9B%BA%E7%AC%94%E8%AE%B0.html#封装" class="sidebar-link">封装</a></li><li class="sidebar-sub-header"><a href="/IT/PHP/PHP%E5%B7%A9%E5%9B%BA%E7%AC%94%E8%AE%B0.html#继承" class="sidebar-link">继承</a></li><li class="sidebar-sub-header"><a href="/IT/PHP/PHP%E5%B7%A9%E5%9B%BA%E7%AC%94%E8%AE%B0.html#重载overloading" class="sidebar-link">重载overloading</a></li><li class="sidebar-sub-header"><a href="/IT/PHP/PHP%E5%B7%A9%E5%9B%BA%E7%AC%94%E8%AE%B0.html#重写-override" class="sidebar-link">重写 override</a></li><li class="sidebar-sub-header"><a href="/IT/PHP/PHP%E5%B7%A9%E5%9B%BA%E7%AC%94%E8%AE%B0.html#类型约束" class="sidebar-link">类型约束</a></li><li class="sidebar-sub-header"><a href="/IT/PHP/PHP%E5%B7%A9%E5%9B%BA%E7%AC%94%E8%AE%B0.html#属性重写" class="sidebar-link">属性重写</a></li><li class="sidebar-sub-header"><a href="/IT/PHP/PHP%E5%B7%A9%E5%9B%BA%E7%AC%94%E8%AE%B0.html#抽象类（abstract）" class="sidebar-link">抽象类（abstract）</a></li><li class="sidebar-sub-header"><a href="/IT/PHP/PHP%E5%B7%A9%E5%9B%BA%E7%AC%94%E8%AE%B0.html#接口-interface" class="sidebar-link">接口 interface</a></li><li class="sidebar-sub-header"><a href="/IT/PHP/PHP%E5%B7%A9%E5%9B%BA%E7%AC%94%E8%AE%B0.html#final类" class="sidebar-link">final类</a></li><li class="sidebar-sub-header"><a href="/IT/PHP/PHP%E5%B7%A9%E5%9B%BA%E7%AC%94%E8%AE%B0.html#类常量-const" class="sidebar-link">类常量 const</a></li><li class="sidebar-sub-header"><a href="/IT/PHP/PHP%E5%B7%A9%E5%9B%BA%E7%AC%94%E8%AE%B0.html#多态" class="sidebar-link">多态</a></li><li class="sidebar-sub-header"><a href="/IT/PHP/PHP%E5%B7%A9%E5%9B%BA%E7%AC%94%E8%AE%B0.html#对象的遍历" class="sidebar-link">对象的遍历</a></li><li class="sidebar-sub-header"><a href="/IT/PHP/PHP%E5%B7%A9%E5%9B%BA%E7%AC%94%E8%AE%B0.html#serialize-un-serialize" class="sidebar-link">serialize un-serialize</a></li><li class="sidebar-sub-header"><a href="/IT/PHP/PHP%E5%B7%A9%E5%9B%BA%E7%AC%94%E8%AE%B0.html#trait" class="sidebar-link">trait</a></li><li class="sidebar-sub-header"><a href="/IT/PHP/PHP%E5%B7%A9%E5%9B%BA%E7%AC%94%E8%AE%B0.html#反射-reflectionclass" class="sidebar-link">反射 ReflectionClass</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p>#php学习笔记</p> <h2 id="php历史"><a href="#php历史" aria-hidden="true" class="header-anchor">#</a> php历史</h2> <h2 id="php基本语法"><a href="#php基本语法" aria-hidden="true" class="header-anchor">#</a> php基本语法</h2> <h2 id="oop-面向对象编程"><a href="#oop-面向对象编程" aria-hidden="true" class="header-anchor">#</a> OOP 面向对象编程</h2> <h3 id="类与对象"><a href="#类与对象" aria-hidden="true" class="header-anchor">#</a> 类与对象</h3> <ol><li>类是抽象的、概念的，代表一类事物</li> <li>对象是具体的，实际的，代表一个具体事物</li> <li>类是对象的模版，对象是类的一个个实例。</li></ol> <h4 id="如何定义一个类"><a href="#如何定义一个类" aria-hidden="true" class="header-anchor">#</a> 如何定义一个类</h4> <div class="language- extra-class"><pre class="language-text"><code>class Cat{
	//声明成员属性 （变量）
	public $name; //属性必需要有访问控制符
	protected $age;
	private $owner;
}
</code></pre></div><h4 id="类名规范"><a href="#类名规范" aria-hidden="true" class="header-anchor">#</a> 类名规范</h4> <ol><li>首字母大写（ 但是  $cat1 = new CAT(); //类名 不区分大小写）</li> <li>驼峰命名</li> <li>名词在前</li> <li>动词在后</li></ol> <h4 id="如何创建对象"><a href="#如何创建对象" aria-hidden="true" class="header-anchor">#</a> 如何创建对象</h4> <div class="language- extra-class"><pre class="language-text"><code>$cat1 = new Cat;

$cat1 = new Cat();
</code></pre></div><h4 id="成员属性-成员变量"><a href="#成员属性-成员变量" aria-hidden="true" class="header-anchor">#</a> 成员属性/成员变量</h4> <p>​	是类的组成部分，可以是基本数据类型或符合数据类型（对象、数组）或资源或NULL</p> <h5 id="访问成员属性"><a href="#访问成员属性" aria-hidden="true" class="header-anchor">#</a> 访问成员属性</h5> <div class="language- extra-class"><pre class="language-text"><code>echo $cat1-&gt;name; //使用对象运算符  -&gt;
</code></pre></div><p>#####对象运算符  -&gt;</p> <h5 id="对象传递机制"><a href="#对象传递机制" aria-hidden="true" class="header-anchor">#</a> 对象传递机制</h5> <div class="language- extra-class"><pre class="language-text"><code>	$cat1 = new Cat();
	$cat1-&gt;name = 'xiaohua';
	$cat2 = $cat1; //值传递：传递的是对象的引用reference，对象标识符
	$cat2 = 'abc'; //不影响$cat1
	
	$cat3 = &amp;$cat1; //地址引用
	$cat3 = 'def'; //此时改变了$cat1
	
</code></pre></div><h4 id="查看对象标识符-1"><a href="#查看对象标识符-1" aria-hidden="true" class="header-anchor">#</a> 查看对象标识符 #1</h4> <p>​	var_dump($cat1);</p> <h4 id="成员函数-成员方法"><a href="#成员函数-成员方法" aria-hidden="true" class="header-anchor">#</a> 成员函数/成员方法</h4> <div class="language- extra-class"><pre class="language-text"><code>class Cat{
	//声明成员属性 （变量）
	public $name; //属性必需要有访问控制符
	protected $age;
	
	public function cry(){
		echo 'miao';
	}
}
</code></pre></div><h5 id="调用成员函数"><a href="#调用成员函数" aria-hidden="true" class="header-anchor">#</a> 调用成员函数</h5> <div class="language- extra-class"><pre class="language-text"><code>$cat1 = new Cat;
//cry();//不可以直接调用
$cat1-&gt;cry();
</code></pre></div><h4 id="构造函数-construct"><a href="#构造函数-construct" aria-hidden="true" class="header-anchor">#</a> 构造函数__construct</h4> <ol><li>是类的一个特殊方法</li> <li>主要作用是 创建对象时 直接<strong>初始化</strong> 赋值</li> <li>没有返回值</li> <li>实例化对象时 系统会自动调用</li> <li>构造函数只能有一个</li> <li>老版本（php4中）构造函数和类名相同 (改类名了怎么办？)，如果有2个形式的构造函数，则优先使用__construct</li> <li>如果定义构造函数后，会覆盖系统默认的空构造函数</li> <li>默认的构造函数方法访问修饰符是public</li></ol> <h5 id="this-当前对象（调用者）"><a href="#this-当前对象（调用者）" aria-hidden="true" class="header-anchor">#</a> this 当前对象（调用者）</h5> <ol><li>系统会给每个对象分配this，代表当前对象（自己的，我的）</li> <li>this时当前的<strong>执行环境</strong></li> <li>this不能在类外部使用</li></ol> <div class="language- extra-class"><pre class="language-text"><code>class Cat{
	public $name;
	public $age;
	
	public function __contruct($iname,$iage){
		//$name = $iname;
		var_dump($this);
		$this-&gt;name = $iname;
		$this-&gt;age = $iage;
	}

}

$cat1 = new Cat('xiaohua',3);
echo $cat1-&gt;name . $cat1-&gt;age;
</code></pre></div><h4 id="析构函数-destruct"><a href="#析构函数-destruct" aria-hidden="true" class="header-anchor">#</a> 析构函数__destruct</h4> <p>作用：释放相关资源</p> <p>code：<code>function __destruct() { }</code></p> <p>先创建的对象后销毁 栈</p> <h6 id="说明"><a href="#说明" aria-hidden="true" class="header-anchor">#</a> 说明</h6> <ol><li>当没有变量指向某个对象时（所有引用都被删除），这个对象就会被销毁</li> <li>在对象销毁之前，会调用析构函数</li> <li>析构函数不是销毁对象本身，而是销毁对象创建的相关资源，如数据库连接等</li></ol> <h6 id="使用场合-最佳事件"><a href="#使用场合-最佳事件" aria-hidden="true" class="header-anchor">#</a> 使用场合/最佳事件</h6> <ol><li>希望在程序还没结束前，就销毁某些实例（显性删除 $cat1 = null;或指向其他）</li> <li>及时销毁对象创建的资源，如数据库连接等</li></ol> <h4 id="垃圾回收♻️机制"><a href="#垃圾回收♻️机制" aria-hidden="true" class="header-anchor">#</a> 垃圾回收♻️机制</h4> <pre><code>1. 当一个对象没有任何引用（变量）指向它的时候，就会成为一个垃圾对象，php就会启动垃圾回收器将其销毁
2. 当程序退出前，php也将启用垃圾回收器，销毁对象
3. php5.3自后对垃圾回收算法优化，解决了**引用环**问题
4. 对象标识符合的引用次数, 每个对象都会分配一个计数器
</code></pre> <h3 id="类的魔术方法-magic-methods"><a href="#类的魔术方法-magic-methods" aria-hidden="true" class="header-anchor">#</a> 类的魔术方法 Magic methods</h3> <ol><li>在满足某种条件下会被系统自动调用（不可手动调用）</li> <li>都是以——开头的函数</li></ol> <p>####一览表</p> <ol><li>__construct</li> <li>__destruct</li> <li>__call  当对象调用一个不可访问或不存在的方法时，__call会被调用。</li> <li>__callStatic</li> <li>__set</li> <li>__get</li> <li>__isset</li> <li>__unset</li> <li>__sleep</li> <li>__wakeup</li> <li>__toString</li> <li>__set_state</li> <li>__clone</li></ol> <h4 id="访问修饰符"><a href="#访问修饰符" aria-hidden="true" class="header-anchor">#</a> 访问修饰符</h4> <p>对属性或方法的访问控制 Access Control 通过在前面添加关键字 public protected private</p> <table><thead><tr><th></th> <th>public</th> <th>protected</th> <th>private</th></tr></thead> <tbody><tr><td>类内</td> <td>√</td> <td>√</td> <td>√</td></tr> <tr><td>类外</td> <td>√</td> <td>X</td> <td>X</td></tr> <tr><td>子类</td> <td>√</td> <td>√</td> <td>X</td></tr></tbody></table> <p>在类外访问private和protected属性，需要定一个public getAtt() 绕行</p> <h4 id="get-set"><a href="#get-set" aria-hidden="true" class="header-anchor">#</a> __get __set</h4> <p>对类中不可访问/不存在的属性 访问/读取时 __get 会被自动调用</p> <p>对类中不可访问/不存在的属性 设置/赋值时 __set 会被自动调用</p> <p>应用： 松散型的php：给不存在的属性赋值时，会设置成功 ！使用--set可以友好提示！</p> <h4 id="isset-unset"><a href="#isset-unset" aria-hidden="true" class="header-anchor">#</a> __isset __unset</h4> <p>对类中不可访问/不存在的属性 进行 isset() / empty()时 __isset 会被自动调用</p> <p>对类中不可访问/不存在的属性 进行 unset()时 __unset 会被自动调用</p> <h4 id="call"><a href="#call" aria-hidden="true" class="header-anchor">#</a> __call</h4> <div class="language- extra-class"><pre class="language-text"><code>class Cat{
	public function __call($method, $agrs){
		return $this-&gt;$agrs[0]($agrs[1],$agrs[2]);
	}
	public function getSum($n1,$n2){
		return $n1+$n2;
	}
}

$cat = new Cat;
$cat-&gt;play('getSum',1,2); //3
</code></pre></div><h3 id="autoload-类的自动-动态加载"><a href="#autoload-类的自动-动态加载" aria-hidden="true" class="header-anchor">#</a> __autoload 类的自动/动态加载</h3> <p>当使用一个没有定义过的类时，就会/才会自动触发__autoload函数</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;?php
//init.php

function myAutoload($className){
	require &quot;./Models/$className.php&quot;;
}

/* 

$classMap =['Cat'=&gt;'../Models/Cat.class.php'];

function __autoload($className){
  global $classMap;
	require &quot;./Class/$className.php&quot;;
}

*/
$cat = new Cat();

spl_autoload_register('myAutoload');

</code></pre></div><h3 id="类的静态属性"><a href="#类的静态属性" aria-hidden="true" class="header-anchor">#</a> 类的静态属性</h3> <p>####静态变量</p> <p>所有对象共享公共的数据 ，可以在定义的时候初始化。</p> <p>初始化在类加载时</p> <p>####静态变量定义</p> <div class="language- extra-class"><pre class="language-text"><code>public static $counts =0;
</code></pre></div><p>####静态变量定义访问</p> <p>​	类内访问 ：范围解析符 self:😗*$**counts++;</p> <p>​	类外+类内 Cat:😗*$**counts; (需要时public)</p> <p>任何一个对象访问时，获取的时相同的值</p> <h4 id="范围解析符"><a href="#范围解析符" aria-hidden="true" class="header-anchor">#</a> 范围解析符 ::</h4> <p>self::</p> <p>####对象运算符  -&gt;</p> <h4 id="this与self-区别"><a href="#this与self-区别" aria-hidden="true" class="header-anchor">#</a> $this与self::区别</h4> <h3 id="类的静态方法"><a href="#类的静态方法" aria-hidden="true" class="header-anchor">#</a> 类的静态方法</h3> <p>静态方法也叫类方法</p> <h4 id="定义"><a href="#定义" aria-hidden="true" class="header-anchor">#</a> 定义</h4> <div class="language- extra-class"><pre class="language-text"><code>public static function cry(){

}
</code></pre></div><h4 id="使用场景-（单例模式）"><a href="#使用场景-（单例模式）" aria-hidden="true" class="header-anchor">#</a> 使用场景 （单例模式）</h4> <ul><li>操作静态变量
<ul><li>静态方法中不可以访问/操作 非静态 属性/变量</li></ul></li> <li>没有对象实例的话，也可以调用方法</li></ul> <p>####调用</p> <ul><li>在类的外部调用静态方法, 则必需为public
<ul><li>Cat::cry();</li> <li>$cat1-&gt;cry();//不推荐</li> <li><s>$cat1::cry(); //极不推荐</s></li></ul></li> <li>在类的内部调用静态方法，
<ul><li>self::cry(); //推荐</li> <li>Cat::cry(); //不推荐</li> <li><s>$this-&gt;cry(); //极不推荐</s></li></ul></li></ul> <h4 id="细节"><a href="#细节" aria-hidden="true" class="header-anchor">#</a> 细节</h4> <h3 id="封装"><a href="#封装" aria-hidden="true" class="header-anchor">#</a> 封装</h3> <ul><li>把同一类食物的属性和行为 包装起来</li></ul> <h3 id="继承"><a href="#继承" aria-hidden="true" class="header-anchor">#</a> 继承</h3> <p>是单继承的，一个类最多有一个父类
简洁，纯洁性
接口可以补充无法多继承的缺陷！</p> <h3 id="重载overloading"><a href="#重载overloading" aria-hidden="true" class="header-anchor">#</a> 重载overloading</h3> <h4 id="call-实现同名函数但不同参数"><a href="#call-实现同名函数但不同参数" aria-hidden="true" class="header-anchor">#</a> __call 实现同名函数但不同参数</h4> <p>####属性的重载(动态添加属性) __get() __set()</p> <div class="language- extra-class"><pre class="language-text"><code>class Cat{
	protected $pro_array = [];
	public function __set($pro_name,$val){
		$this-&gt;pro_array[$pro_name] = $val;
	}
	public function __get($pro_name){
	 return $this-&gt;pro_array[$pro_name];//if isset
	}
}
$cat = new Cat();
$cat-&gt;name = 'xiaohua';

</code></pre></div><h3 id="重写-override"><a href="#重写-override" aria-hidden="true" class="header-anchor">#</a> 重写 override</h3> <p>子类重写父类public/protected方法或属性</p> <p>重写要求 函数名和参数个数 完全一致</p> <p>重写方法内 访问父类的的静态属性 parents::$total，但这个静态属性必需可以被子类访问（即public或protected）</p> <p>子类可以调用父类的构造方法 parents::__construct();</p> <p>子类必需要和父类的 类型约束 保持一致</p> <p>子类方法不能缩小父类访问权限 Access Level</p> <h3 id="类型约束"><a href="#类型约束" aria-hidden="true" class="header-anchor">#</a> 类型约束</h3> <ul><li>对象</li> <li>数组 array</li> <li>callable 毁掉函数</li> <li>如果默认值null，调用时可以为NULL</li> <li>不能是int string traits</li></ul> <h3 id="属性重写"><a href="#属性重写" aria-hidden="true" class="header-anchor">#</a> 属性重写</h3> <h3 id="抽象类（abstract）"><a href="#抽象类（abstract）" aria-hidden="true" class="header-anchor">#</a> 抽象类（abstract）</h3> <h4 id="为什么要使用抽象类技术"><a href="#为什么要使用抽象类技术" aria-hidden="true" class="header-anchor">#</a> 为什么要使用抽象类技术</h4> <ul><li>规范类的设计（模糊设计一个类拥有的行为）</li> <li>关键词： abstract</li> <li>抽象类abstract不可以实例化</li> <li>抽象类可以没有抽象方法，但包含抽象方法的类一定是抽象类</li></ul> <h4 id="抽象方法"><a href="#抽象方法" aria-hidden="true" class="header-anchor">#</a> 抽象方法</h4> <ul><li>抽象方法不能有函数体： abstract public function say();</li> <li>继承子类必需实现抽象类的所有abstract方法，除非它也是abstract类</li> <li>重写overwrite子类实现的方法的访问修饰符 &gt;= 父类</li></ul> <h4 id="抽象类与抽象方法的关系"><a href="#抽象类与抽象方法的关系" aria-hidden="true" class="header-anchor">#</a> 抽象类与抽象方法的关系</h4> <ul><li><p>如果一个类包含抽象方法，那么这个类一定是抽象类</p></li> <li><p>抽象类中可以包含非抽象方法</p></li></ul> <h3 id="接口-interface"><a href="#接口-interface" aria-hidden="true" class="header-anchor">#</a> 接口 interface</h3> <ul><li>接口就是生命一个方法，供其他类来实现</li> <li>设计思想： 高内聚低耦合</li> <li>接口就是规范，是更加抽象的抽象类，解决多层继承耦合问题</li></ul> <div class="language-interface iName{ extra-class"><pre class="language-text"><code>interface iName{
  //属性 iName::A
  const A=90 
  //方法
}

class iPhone extents Phone implements 接口1，接口2{
    //必需实现接口1和2的所有方法
} ```

//接口之间可以多继承 
interfact iUsb extents iUsb1 iUsb2{
}

</code></pre></div><p>####使用场合</p> <ul><li>定规范</li> <li>多个同级类，同样方法wrtie()又有不同的行为。比如，有的写数据库，有的写文件</li></ul> <h4 id="细节-2"><a href="#细节-2" aria-hidden="true" class="header-anchor">#</a> 细节</h4> <ol><li>不能实例</li> <li>接口的所有方法都不能有方法体</li> <li>可以实现多个接口</li> <li>接口中的属性必需是 public常量</li> <li>接口的方法都必需是public</li> <li>接口之间可以多继承</li></ol> <p>在不打破继承关系的前提下扩充类功能，非常灵活</p> <h3 id="final类"><a href="#final类" aria-hidden="true" class="header-anchor">#</a> final类</h3> <p>不希望任何类继承的类
不可以覆盖重写的方法也可以使用final修饰
Final 方法可以被继承，但不可以重写
final类是可以被实例化的
final public say（）｛｝
不能修饰属性</p> <h3 id="类常量-const"><a href="#类常量-const" aria-hidden="true" class="header-anchor">#</a> 类常量 const</h3> <p>不允许改动的 比如圆周率 不用$符号，大写，必须赋值，都必须是public</p> <h3 id="多态"><a href="#多态" aria-hidden="true" class="header-anchor">#</a> 多态</h3> <p>php天生就是多态语言，可以通过继承父类或实现接口来体现多态。</p> <p>好处：代码维护或扩展</p> <div class="language- extra-class"><pre class="language-text"><code>class Animal{
	public $name;
	function __construct($name){
		$this-&gt;name = $name;
	}
}

class Dog extends Animal{
	public function showInfo(){
		return $this-&gt;name;
	}
}

class Cat extends Animal{
	public function showInfo(){
		return $this-&gt;name;
	}
}

class Food{
	public $name;
	function __construct($name){
		$this-&gt;name = $name;
	}
}

class Fish extends Food{
	public function showInfo(){
		return $this-&gt;name;
	}
}

class Bone extends Food{
	public function showInfo(){
		return $this-&gt;name;
	}
}

class Master {
	public	$name;
	
	// 这里实现了多态！！！使用类型约束 限定 一下更好！
	public function feed(Animal $animal, Food $food){
		echo PHP_EOL. $animal-&gt;showInfo();
		echo '喜欢吃';
		echo PHP_EOL. $food-&gt;showInfo();
	}
}

$master = new Master('xiaohong');
$cat = new Cat('小花猫');
$fish = new Fish('小鱼鱼');
$master-&gt;feed($cat, $fish);

$dog = new Dog('大黄');
$bone = new Fish('大棒骨🦴');
$master-&gt;feed($dog, $bone);

</code></pre></div><h3 id="对象的遍历"><a href="#对象的遍历" aria-hidden="true" class="header-anchor">#</a> 对象的遍历</h3> <ul><li>对象遍历只能遍历对象的属性值</li> <li>在类外遍历时，只能遍历到public属性</li> <li>如果要遍历所有属性，需要成员方法在 实例里/类里 遍历</li></ul> <div class="language- extra-class"><pre class="language-text"><code>public class Dog{
	public $name='xiaomao';
	private $age=1;
	protected $color;
	//内部可以访问到所有属性
	function getVars(){
		foreach($this as $key=&gt;$val){
			echo PHP_EOL.&quot;$key=&gt;$val&quot;;
		}
	}
}

$dog1 = new Dog();
//外部遍历到public属性
foreach($dog as $key=&gt;$val){
	echo PHP_EOL.&quot;$key=&gt;$val&quot;;
}

</code></pre></div><h4 id="内置标准类-stdclass"><a href="#内置标准类-stdclass" aria-hidden="true" class="header-anchor">#</a> 内置标准类 stdClass</h4> <ul><li>php中有一个类 stdClass，不需要创建就可以使用</li> <li>通常以对象的方式管理数据</li></ul> <div class="language- extra-class"><pre class="language-text"><code>$person = new stdClass();
var_dump($person);
$person-&gt;name = '猪八戒';
var_dump($persion);
</code></pre></div><h4 id="其他数据类型-转换成对象"><a href="#其他数据类型-转换成对象" aria-hidden="true" class="header-anchor">#</a> 其他数据类型 转换成对象</h4> <div class="language- extra-class"><pre class="language-text"><code>$heros = ['no1'=&gt;'宋江'，'no2'=&gt;'小吴'];
//当我们把一个数组转换成一个对象后，
//它成为一个stdClass对象实例
//如果是一个关联数组，数组的key编程属性名
//如果是一个索引数组？？？
$heros = (object) $heros;


$age=90;
$age = (object) $age;
</code></pre></div><h3 id="serialize-un-serialize"><a href="#serialize-un-serialize" aria-hidden="true" class="header-anchor">#</a> serialize un-serialize</h3> <ul><li><p>对象的序列化和反序列化</p></li> <li><p>序列化 保存为字符串 $str = serialize($obj1);</p></li> <li><p>反序列化 把字符串还原为原来的对象，需要引入类的定义</p> <ul><li>$obj1 = unserialize($str);</li></ul></li></ul> <h3 id="trait"><a href="#trait" aria-hidden="true" class="header-anchor">#</a> trait</h3> <div class="language- extra-class"><pre class="language-text"><code>trait Abc{
	function sum($n1,$n2){
		return $n1+$n2;
	}
	function getMax($arr){
		return max($arr);
	}
}

class Cde{
	use Abc;
}
</code></pre></div><ul><li>代码函数级别复用</li> <li>trait不可以实例化</li> <li>优先级为最低，可以覆盖</li></ul> <h3 id="反射-reflectionclass"><a href="#反射-reflectionclass" aria-hidden="true" class="header-anchor">#</a> 反射 ReflectionClass</h3> <div class="language- extra-class"><pre class="language-text"><code>class IndexAction{
	public function index(){
		echo 'Index';
	}
	public function test(){
		echo PHP_EOL.__CLASS__.__FUNCTION__.__LINE__;
	}
	
	public function _before_index(){
		echo PHP_EOL.__CLASS__.__FUNCTION__.__LINE__;
	}
	
	public function _after_index(){
		echo PHP_EOL.__CLASS__.__FUNCTION__.__LINE__;
	}
}
//
var_dump(Reflection::export('IndexAction'));

//需求是 IndexAction中的方法和访问控制符是不确定的。如果是public，可以执行
//如果存在before/after方法，并且是public，则执行

$reflector = new ReflectionClass('IndexAction');
if($reflector-&gt;hasMethod('index')){
	echo 'has-index';
	$reflectorIndex = $reflector-&gt;getMethod('index');
	if($reflectorIndex-&gt;isPublic()){
		echo 'index is public';
		//before
		if($reflector-&gt;hasMethod('_before_index')){
			$reflectorBefore = $reflector-&gt;getMethod('_before_index');
			if($reflectorBefore-&gt;isPublic()){
				$reflectorBefore-&gt;invoke(new $reflector-&gt;newInstance());
			}
		}
		//index
		
		//after
	}
}else{
	echo 'no-index';
}
</code></pre></div></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated: </span> <span class="time">11/6/2020, 10:54:10 AM</span></div></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.35fdc654.js" defer></script><script src="/assets/js/2.8f7dda8c.js" defer></script><script src="/assets/js/12.8b453b2c.js" defer></script>
  </body>
</html>
